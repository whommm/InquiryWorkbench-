# SmartProcure（智能采购工作台）项目说明文档

本文档面向“不写代码但需要掌握项目情况”的读者，解释 SmartProcure 当前实现了什么、核心流程怎么走、关键文件在哪里、如何运行与演示，以及已知风险与下一步建议。

## 1. 一句话概括

SmartProcure 是一个“左侧聊天、右侧表格”的智能采购工作台：用户用自然语言提交报价信息，系统会把信息写回到 Excel 风格表格，并按“单价最优优先”的规则自动把前三家报价排序。

## 2. 你能看到的功能（产品视角）

### 2.1 页面结构（演示时能直接讲清楚）

- 左侧：聊天窗口（输入报价、接收追问、上传 Excel）
- 右侧：表格（Univer 表格组件，展示询价表与写入后的报价）
- 核心体验：你只要说“第2行，单价5000，含税含运，货期3天，找张三”，系统会把报价写入对应行并自动排序

对应实现：
- 前端页面组合：[App.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/App.tsx)
- 左右分栏布局：[Layout.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/components/Layout.tsx)
- 聊天面板：[ChatPanel.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/components/ChatPanel.tsx)
- 表格组件（Univer）：[UniverSheet.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/components/UniverSheet.tsx)

### 2.2 两种输入方式

1) 文字对话输入（主流程）
- 输入：报价信息（行号/物料名 + 单价 + 是否含税 + 是否含运 + 货期 + 供应商信息）
- 输出：要么追问补充信息（ASK），要么写表成功（WRITE）

2) 上传 Excel（导入表格数据）
- 支持 .xlsx/.xls
- 后端会读取 Excel，转换成“二维数组”（第一行是表头），回传前端渲染

对应实现：
- 前端 API：上传/聊天/初始化 [api.ts](file:///e:/InquiryWorkbench/smart-procure/frontend/src/utils/api.ts)
- 后端上传接口：[routes.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/api/routes.py#L440-L465)

## 3. 技术架构（给管理层/干系人的可讲版本）

### 3.1 前后端分离

- 前端：React + Vite + Tailwind，负责 UI 与交互
- 后端：FastAPI，负责解析 Excel、拼上下文、调用大模型、执行确定性写表算法
- 通信：HTTP JSON（所有后端接口统一在 `/api/*`）

对应入口文件：
- 前端入口：[main.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/main.tsx)
- 后端入口：[main.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/main.py)

### 3.2 “可控智能”策略（为什么不是让大模型直接改表）

系统把“大模型做的事”和“确定性代码做的事”严格分开：

- 大模型负责：从用户话里提取结构化字段（行号/物料名、单价、含税、含运、货期、供应商等），并决定 ASK 还是 WRITE
- 代码负责：真正写入表格、以及“按单价排序 + 槽位顺移”这类必须稳定可复现的业务规则

这样做的好处：
- 业务规则稳定可验收（不会因为模型随机性导致乱排序）
- 可以写单元测试覆盖关键规则（仓库已包含相关测试用例）

对应实现：
- 两阶段 Agent（Planner/Writer）：[agent_runtime.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/services/agent_runtime.py)
- 写表与排序算法：[excel_core.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/services/excel_core.py)

## 4. 核心业务数据：Excel 表=数据库

### 4.1 表头（列定义）怎么来的

后端把表格列名当成“契约”：只要表头符合约定，系统就能识别可写列并写入。

当前项目内置的表头生成逻辑：
- 基础列：序号/物品名称/规格/数量/单位/品牌
- 报价列：按 Slot 1/2/3 重复生成（品牌、备注、单价、含税、含运、货期、供应商）

对应实现：
- [columns.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/models/columns.py)

### 4.2 为什么要有“Slot 1/2/3”

每个物料行最多保留 3 家报价（可理解为 Top 3）。当新报价进入时：
- 会根据单价插入到合适位置
- 原有数据会整体“顺移”（不是只移动单价，而是整组字段一起移动）

这就是规格书里提到的“三栏联动排序”。

## 5. 端到端流程（从你输入一句话到表格变更）

### 5.1 初始化表格

1) 前端启动后会请求后端初始化接口  
2) 后端返回一份二维数组：第一行表头 + 两行示例物料  
3) 前端把数据喂给表格组件渲染

对应实现：
- 前端初始化：[useProcureState.ts](file:///e:/InquiryWorkbench/smart-procure/frontend/src/hooks/useProcureState.ts#L16-L30)
- 后端初始化接口：[main.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/main.py#L18-L32)

### 5.2 对话写表（最重要的主链路）

1) 前端把三类信息发送给后端：
- message：用户这句话
- current_sheet_data：当前表格二维数组（包含表头+所有行）
- chat_history：对话历史（用于上下文）

对应实现：[api.ts](file:///e:/InquiryWorkbench/smart-procure/frontend/src/utils/api.ts#L17-L28)

2) 后端做四件事：
- 根据表头“识别列”并构建 schema（哪些列是单价/含税/含运/货期/供应商）
- 生成一段摘要（有哪些行、哪些品牌、每行已询到几家）
- 进入两阶段 Agent：
  - Planner：允许调用工具做“定位行/取快照/供应商查询”，输出 DONE 草稿
  - Writer：根据草稿与工具结果输出 ASK 或 WRITE 的结构化 JSON
- 若 WRITE：调用确定性写表算法，写入并排序，然后把 updated_sheet 返回前端

对应实现：
- 聊天主接口：[routes.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/api/routes.py#L182-L438)
- 表头识别与行定位工具：[sheet_schema.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/services/sheet_schema.py)
- 两阶段 Agent 运行时：[agent_runtime.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/services/agent_runtime.py)
- 写表与排序算法：[excel_core.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/services/excel_core.py)

3) 前端收到后端返回：
- action=ASK：把后端的追问直接显示到聊天里
- action=WRITE：显示“更新成功”，并用 updated_sheet 覆盖前端 sheetData，从而触发表格刷新

对应实现：[useProcureState.ts](file:///e:/InquiryWorkbench/smart-procure/frontend/src/hooks/useProcureState.ts#L32-L57)

## 6. 大模型（LLM）接入说明（怎么调用、失败会怎样）

### 6.1 当前使用的模型/网关

后端通过 OpenAI SDK 调用 DeepSeek 兼容接口：
- base_url 固定为 `https://api.deepseek.com`
- model 使用 `deepseek-chat`

对应实现：[llm.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/core/llm.py#L10-L57)

### 6.2 API_KEY 的加载方式

- 后端启动时会从 `backend/.env` 读取 `API_KEY`
- 如果没有有效 key 或包含 placeholder，会进入 mock 模式（用正则模拟“第2行 100元”等写表）

对应实现：
- 环境变量加载：[config.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/core/config.py)
- mock 行为：[llm.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/core/llm.py#L34-L115)

安全注意：
- `backend/.env` 应只在本机/服务器上存在，不应进入版本库
- 本仓库已增加忽略规则以避免误提交（见根目录 `.gitignore`）

## 7. 前端表格刷新机制（为什么能“稳定刷新”）

Univer 组件初始化一次后，不通过反复销毁/重建 workbook 的方式刷新数据，而是：
- 获取 active sheet
- 用 Range.setValues 一次性批量写入二维数据
- 同时监听用户在表格里的直接编辑（command executed），把改动反向同步回 React state

对应实现：[UniverSheet.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/components/UniverSheet.tsx#L53-L405)

## 8. 运行与部署（最少步骤版）

### 8.1 Docker 一键联调（推荐）

目录：`smart-procure/deploy/`
- 后端端口：18000
- 前端端口：6789（映射到容器内的 5173）

核心编排文件：
- [docker-compose.yml](file:///e:/InquiryWorkbench/smart-procure/deploy/docker-compose.yml)

运行要点（描述性说明）：
- 前端通过 Vite proxy 把 `/api` 转发到后端（在容器里指向 `http://backend:18000`）
- 后端启用 `--reload`，便于开发调试

### 8.2 本地非 Docker（给开发同学）

- 后端：安装 requirements 后运行 uvicorn（入口是 `app.main:app`）
- 前端：在 `frontend/` 下 `npm run dev`
- 前端代理默认指向 `http://localhost:18000`（见 [vite.config.ts](file:///e:/InquiryWorkbench/smart-procure/frontend/vite.config.ts#L7-L19)）

## 9. 已知问题与风险（项目现状评估）

### 9.1 密钥管理风险（高）

- 运行所需的 `API_KEY` 必须当作敏感信息管理（只放环境变量/私有配置中）
- 如果该 key 曾被公开展示或提交到公开仓库，应立刻在供应商侧撤销并重新生成

### 9.2 Dockerfile.frontend 存在“未完成的生产构建段落”（中）

[Dockerfile.frontend](file:///e:/InquiryWorkbench/smart-procure/deploy/Dockerfile.frontend) 当前以 dev 方式工作是正常的，但文件末尾残留 Nginx 相关 CMD/EXPOSE，若未来要做生产镜像，需要整理为“两阶段构建：build -> nginx serve”的标准结构。

### 9.3 Excel 表头兼容性（中）

系统依赖表头识别：
- 如果上传的 Excel 表头命名差异过大，可能导致“未检测到报价列”从而无法写表
对应处理逻辑在 [sheet_schema.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/services/sheet_schema.py)（同义词映射与 slot 识别）。

## 10. 关键文件地图（快速定位）

### 10.1 前端（UI）

- 页面入口与组合：frontend/src/[main.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/main.tsx)，[App.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/App.tsx)
- 业务状态编排：frontend/src/hooks/[useProcureState.ts](file:///e:/InquiryWorkbench/smart-procure/frontend/src/hooks/useProcureState.ts)
- 聊天与上传：frontend/src/components/[ChatPanel.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/components/ChatPanel.tsx)
- 表格渲染与写入：frontend/src/components/[UniverSheet.tsx](file:///e:/InquiryWorkbench/smart-procure/frontend/src/components/UniverSheet.tsx)
- API 封装：frontend/src/utils/[api.ts](file:///e:/InquiryWorkbench/smart-procure/frontend/src/utils/api.ts)

### 10.2 后端（API + 业务规则）

- FastAPI 入口：backend/app/[main.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/main.py)
- 聊天/上传接口：backend/app/api/[routes.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/api/routes.py)
- LLM 封装：backend/app/core/[llm.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/core/llm.py)
- 表头/槽位识别：backend/app/services/[sheet_schema.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/services/sheet_schema.py)
- 三栏联动排序：backend/app/services/[excel_core.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/services/excel_core.py)
- 供应商 mock 数据：backend/app/services/[supplier_mock.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/services/supplier_mock.py)
- 回归测试：backend/app/tests/[test_regressions.py](file:///e:/InquiryWorkbench/smart-procure/backend/app/tests/test_regressions.py)

## 11. 术语表（阅读文档时用）

- SheetData：前后端传递的二维数组（第一行是表头）
- Slot：一组报价字段的“槽位”，例如单价1/含税1/含运1/货期1/供应商1
- ASK：后端要求用户补充信息（不写表）
- WRITE：后端确认信息完整，执行写表并返回 updated_sheet
